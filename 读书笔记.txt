1974 TCP 传输控制协议

1984 蒂姆伯纳斯李 首个网页浏览器  www

OSI RM 开放系统互联参考模型

应用层  http
表示层  数据表示  数据安全 数据压缩
会话层  建立 管理 终止 会话
传输层  数据成数据段 segment 用一个寻址机制来标识一个特定的应用程序---端口号  网关
网络层  分割 重新组合数据包packet 基于网络层地址 IP地址 路径选择             路由器
数据链路层  将比特信息封装成数据帧frame   网桥 交换机 网卡
物理层  传输bit流   建立 维护  取消物理连接   光纤 同轴电缆 中继器  集线器

TCPIP  应用层  传输层  网络层  网络接口层（物理层  数据链路层）

IP协议 是不可靠 无连接协议

TCP 传输控制协议 是面向连接 可靠协议

UDP 用户数据报协议   是不可靠 无连接协议

TCP报文:
0-15     源端口号
16-31    目的端口号

32-63    序号字段  SEQ序号 数据流中每一个字节都有编上一个序号 序号字段的值
是本报文段所发送的数据的第一个字节的序号

64-95    确认字段  ACK序号 期待收到对方的下一个报文段的第一个字节序号
只有ACK标志位为1时 确认序号字段才有 ACK = SEQ + 1

标志位 6个
URG  紧急位
ACK  只有当ACK = 1 确认号字段才有效
PSH  推送位 push 当PSH为1的报文段 就尽快交付给接收应用进程 不再等到整个缓存都填满了后再向上交付
RST  复位  reset 当rest = 1 表明TCP连接中出现严重差错 必须释放连接 然后再重新建立连接
SYN  同步比特  当 SYN = 1 表示这是一个连接请求或连接接收报文
FIN  终止比特  用来释放一个连接  当FIN = 1时 表明此报文段的发送端的数据已发送完毕 并要求释放运输连接

注意: 不要将确认序号ACK与标志位中的ACK搞混了 确认方ACK = 发起方SEQ + 1 两端配对

数据偏移 4bit 

窗口字段 16bit 用来控制对方发送数量 单位字节 byte TCP连接的一端根据设置的缓存空间大小确定自己的接收窗口大小 然后通知对方以确定对方的发送窗口的上限

校验和  16bit 校验和字段校验的范围包括首部和数据两部分 在计算校验和时 要在TCP报文段的前面上12字节的伪首部

紧急指针字段 16bit 紧急指针指出在本报文段中的紧急数据的最后一个字节的序号

选项字段  长度可变  TCP只规定了一种选项 即最大报文段的长度MSS Maximum segment size MSS告诉对方TCP 我的缓存
所能接受的报文段的数据字段的最大长度是MSS个字节

TCP的连接和建立都是采用客户服务器方式

主动发起连接建立的应用进程叫客户端 Client

被动等待连接建立的应用进程叫做服务器 server

TCP的三次握手
Three-way shakehand

客户端                             服务器
1   客户端发送  SYN  SEQ=x  向服务器建立连接的请求
2   服务器发送  SYN ACK 这两个标志位  SEQ=y ACK=x+1 向客户端发一个报文 这个报文确认服务器同意客户端向服务器建立请求 同时服务器向客户端发送建立连接请求
3   客户端发送  ACK SEQ=x ACK=y+1  向服务器发送一个报文 这个报文客户端确认服务器建立连接的请求

TCP的四次挥手
Four-way wavehand
客户端向服务器发送终止连接请求报文
服务器向客户端发送同意终止连接的确认报文
服务器客向户端发送终止连接请求报文
客户端向服务器发送同意终止连接的确认报文 

SEQ 是 发送报文的序号
ACK 是 已经收到报文的序号

客户端                             服务器
1  --->     ACK=1 FIN=1 标志位   SEQ=x  ACK=y
2  <---     ACK=1       标志位   SEQ=y  ACK=x+1
3  <---     ACK=1 FIN=1 标志位   SEQ=y+1
4  --->     ACK=1       标志位   SEQ=x+1  ACK=y+2

为何要两次发送终止请求？
由于TCP连接是全双工 每个方向都必须要单独进行关闭

块 segment 传输层   TCP
包 packet  网络层   IP
帧 frame   数据链路层


